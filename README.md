# Stasher Backend Interview Challenge

To implement this, I added the requested query parameters and went from there. I used Flask's standard `request.query.get`, which works well enough and has type casting. Every parameter is required except the radius_km, which makes me a bit unsure about why lat and lng are not also optional, since in my implementation, they are only used to calculate distance. The dropoff and pickup example provided in the README did not work with python's standard fromisoformat, as the timezone is not included in the ISO 8601 format. To fix this, I simply stripped the timezone, and assume everything is UTC.
For the distance calculation, I used `ST_DistanceSphere`, following this example: https://dev.to/dm8ry/postgresql-how-to-calculate-the-distance-between-two-cities-based-on-their-corresponding-gps-data-23cm.
For the capacity calculation, what needs to be checked is maximum sum of `bag_count` for every time between pickup and dropoff. However, since a peak can only happen when a bag is dropped off, the only times that need to be checked are `Booking.dropoff_time` for very booking in that stashpoint. The maximum of sum of these bag counts will give the peak usage value. Available capacity is calculated by subtracting the peak usage from the total capacity. Despite the query being complex, I was able to do it all in SQL without using python, which makes this performant.

## Possible Enhancements

I feel the code organization could use a bit of work, as all the logic is in the endpoint. The query param handling is quite verbose using flask's default functions, and integrating pydantic or something similar would remove a lot of code here. The labels in the query are also a bit hard to read, but I feel that splitting them into another function is a bit challenging, since this code is not very reusable outside of the context of this endpoint. This is also a consequence of the capacity query itself being very complex. For this query itself, there definitely need to be some indexes for this to scale better. There are simple ones like `is_cancelled`, but more complex indexes for the time range overlap should definitely be considered.
